package com.csite.site.engine;

import java.util.ArrayList;

public class Game {

    //Id should not be generated by User.
    //Should be generated from GameRepository to ensure that Id is unique.
    // Id is not used by game engine itself.
    private String id;

    private Piece board[][] = new Piece[8][8];

    private ArrayList<String> moves = new ArrayList<String>();

    //value of 0 represents white, and 1 represents black. Turn should only be either 0 or 1.
    //value < 0 represents game over and -1 for black win and -2 for white win.
    private int turn;

    public Game() {
        //Don't use this constructor. Only for testing.

        this.id = "nkfadjf"; //Just testing value for id.
        reset_board(); //sets Piece Board[][] to default value.
        this.turn = 0; //0 for white, 1 for black.
    }

    public Game(String id) {
        this.id = id;
        reset_board();
        this.turn = 0;
    }

    public Game(String id, String board, String moves, int turn) {
        this.id = id;
        board_from_string(board);
        moves_from_string(moves);
        this.turn = turn;
    }

    //Standard getters for id, board, and turn.
    //-------------------------------------------
    public String getId() {
        return this.id;
    }

    public String getBoard() {
        String g = "";
        for (int i = 0; i < 8; i++) {
            for (int j = 0; j < 8; j++) {
                if (board[i][j] == null)  { g += "."; }
                else                      { g += this.board[i][j].to_string(); }
            }
            if (i <= 6) { g += "\n"; }
        }
        return g;
    }

    public String getMoves() {
        String str_moves = "";
        for (int i = 0; i < this.moves.size(); i++) {
            str_moves += this.moves.get(i);
            if (i < (this.moves.size() - 1)) { str_moves += ","; }
        }
        return str_moves;
    }

    public int getTurn() {
        return this.turn;
    }

    //-------------------------------------------

    public void board_from_string(String str_pure) {
        String bdd[] = str_pure.split("\n");
        int color = -1;
        for (int i = 0; i < 8; i++) {
            for (int j = 0; j < 8; j++) {
                color = (bdd[i].substring(j, j + 1).equals(bdd[i].substring(j, j + 1).toLowerCase())) ? 0 : 1;
                switch (bdd[i].substring(j, j + 1).toLowerCase()) {
                    case "p":  this.board[i][j] =   new   Pawn(i, j, color);  break;
                    case "k":  this.board[i][j] =   new   King(i, j, color);  break;
                    case "q":  this.board[i][j] =   new  Queen(i, j, color);  break;
                    case "b":  this.board[i][j] =   new Bishop(i, j, color);  break;
                    case "n":  this.board[i][j] =   new Knight(i, j, color);  break;
                    case "r":  this.board[i][j] =   new   Rook(i, j, color);  break;
                    default:   this.board[i][j] =   null;                     break;
                }
            }
        }
    }

    public void moves_from_string(String str_moves) {
        String arr_moves[] = str_moves.split(",");
        for (int i = 0; i < arr_moves.length; i++) {
            if (arr_moves[i].length() > 1) {
                this.moves.add(arr_moves[i]);
            }
        }
    }

    private void invert_turn() {
        //changes turn from white to black and from white to black.
        turn = Math.abs(turn - 1);
    }

    public boolean is_checkmate() {
        for (int i = 0; i < 8; i++) {
            for (int j = 0; j < 8; j++) {
                if (board[i][j] != null && board[i][j].Color == turn) {
                    for (int k = 0; k < 8; k++) {
                        for (int c = 0; c < 8; c++) {
                            if (valid_move(i, j, k, c, true)) {
                                return false;
                            }
                        }
                    }
                }
            }
        }
        return true;
    }

    public boolean undo_check(int posy, int posx, int new_posy, int new_posx) {
        //Move piece.
        Piece old_spot = board[new_posy][new_posx];
        board[new_posy][new_posx] = board[posy][posx];
        board[posy][posx] = null;
        board[new_posy][new_posx].update_position(new_posy, new_posx);

        //Get if that color is still in check.
        boolean checked = is_check();

        //undo move.
        board[posy][posx] = board[new_posy][new_posx];
        board[new_posy][new_posx] = old_spot;
        board[posy][posx].update_position(posy, posx);

        return checked;
    }

    public boolean is_check() {
        int k_pos[];
        if (turn == 0)  { k_pos = get_position_piece("k"); }
        else            { k_pos = get_position_piece("K"); }
        invert_turn();
        for (int i = 0; i < 8; i++) {
            for (int j = 0; j < 8; j++) {
                if (valid_move(i, j, k_pos[0], k_pos[1], false)) { invert_turn(); return true; }
            }
        }

        invert_turn();
        return false;
    }

    public boolean valid_move(int posy, int posx, int n_posy, int n_posx, boolean u_check) {
        if (board[posy][posx] == null || board[posy][posx].Color != turn || (posy == n_posy && posx == n_posx)) { return false; }
        if (!board[posy][posx].is_valid_move(board, n_posy, n_posx)) { return false; }
        if ( u_check) { return !undo_check(posy, posx, n_posy, n_posx); }

        return true;
    }

    public boolean move_piece(int posy, int posx, int n_posy, int n_posx) {

        //Check if move is valid
        if (!valid_move(posy, posx, n_posy, n_posx, true)) {
            return false;
        }

        //Add move to this.moves
        String table[] = {"a", "b", "c", "d", "e", "f", "g"};
        String str_move = board[posy][posx].to_string() + table[posx] + Integer.toString(posy);
        if (board[n_posy][n_posx] != null) {
            str_move += board[n_posy][n_posx].to_string();
        }
        str_move += table[n_posx] + Integer.toString(n_posy);
        this.moves.add(str_move);

        //Update Board
        board[n_posy][n_posx] = board[posy][posx];
        board[n_posy][n_posx].update_position(n_posy, n_posx);
        board[posy][posx] = null;
        invert_turn();

        //Check if it is checkmate
        if (is_checkmate()) {
            if (turn == 0) { turn = -1; }
            else if (turn == 1) {turn = -2; }
        }

        //Valid Move
        return true;
    }

    private void reset_board() {
        String strboard = "rnbqkbnr\n" +
                          "pppppppp\n" +
                          "        \n" +
                          "        \n" +
                          "        \n" +
                          "        \n" +
                          "PPPPPPPP\n" +
                          "RNBQKBNR";

        board_from_string(strboard);
    }

    public int[] get_position_piece(String piece) {
        int[] abc = {-1, -1};
        for (int i = 0; i < 8; i++) {
            for (int j = 0; j < 8; j++) {
                if (board[i][j] != null && board[i][j].to_string().equals(piece)) {
                    abc[0] = i; abc[1] = j;
                    return abc;
                }
            }
        }
        return abc;
    }




}
